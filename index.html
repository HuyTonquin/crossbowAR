<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AR Crossbow Shooting Simulation</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #228B22;
    }
    canvas {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: Arial, sans-serif;
      background: rgba(20, 146, 220, 0.7);
      padding: 10px;
      border-radius: 5px;
      z-index: 10;
    }
    #shootBtn {
      position: absolute;
      bottom: 30px;
      right: 30px;
      z-index: 10;
      font-size: 2em;
      padding: 0.5em 1.2em;
      border-radius: 0.5em;
      border: none;
      background: #1e90ff;
      color: white;
      opacity: 0.85;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      display: none;
    }
    #hitFlash {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(255, 0, 0, 0.25);
      z-index: 9999;
      pointer-events: none;
    }
    @keyframes hitFlashAnim {
      0% { opacity: 0.7; }
      100% { opacity: 0; }
    }
    #healthBarContainer {
      position: absolute;
      top: 10px;
      right: 20px;
      background: rgba(20, 146, 220, 0.7);
      padding: 8px 14px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.13);
      display: block;
      z-index: 10;
    }
    #restartBtn {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      font-size: 1.3em;
      padding: 0.5em 1.2em;
      border-radius: 0.5em;
      border: none;
      background: #e67e22;
      color: white;
      opacity: 0.85;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }
    #aimBtn {
      position: absolute;
      bottom: 100px;
      right: 30px;
      z-index: 10;
      font-size: 1.3em;
      padding: 0.5em 1.2em;
      border-radius: 0.5em;
      border: none;
      background: #43a047;
      color: white;
      opacity: 0.85;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }
    #backBtn {
      position: absolute;
      bottom: 100px;
      right: 130px;
      z-index: 10;
      font-size: 1.3em;
      padding: 0.5em 1.2em;
      border-radius: 0.5em;
      border: none;
      background: #b71c1c;
      color: white;
      opacity: 0.85;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      display: none;
    }
    #iframeContainer {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 1000;
      background: #228B22;
    }
    #gameIframe {
      width: 100vw;
      height: 100vh;
      border: none;
    }
    #debug {
      position: absolute;
      top: 100px;
      left: 10px;
      color: yellow;
      font-family: Arial, sans-serif;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 5px;
      z-index: 10;
    }
    #startAR {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 1.5em;
      padding: 10px 20px;
      background: #1e90ff;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      z-index: 10;
    }
    #reticle {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 20px;
      height: 20px;
      border: 2px solid white;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      z-index: 10;
      display: none;
    }
  </style>
</head>
<body>
  <div id="info">
    <p>Co Loa Crossbow</p>
    <p>Score: <span id="score">0</span></p>
    <p>Accuracy: <span id="accuracy">0%</span></p>
  </div>
  <div id="healthBarContainer">
    <div id="healthBarBg" style="width:120px;height:18px;background:#333;border-radius:8px;overflow:hidden;">
      <div id="healthBar" style="height:100%;width:100%;background:#4caf50;transition:width 0.3s,background 0.3s;"></div>
    </div>
    <span id="healthLabel" style="margin-left:10px;vertical-align:middle;">100</span>
  </div>
  <button id="shootBtn">Shoot</button>
  <button id="restartBtn">Restart</button>
  <button id="aimBtn">Aim</button>
  <button id="backBtn">Back</button>
  <button id="startAR">Start AR</button>
  <div id="reticle"></div>
  <div id="iframeContainer">
    <iframe id="gameIframe" src=""></iframe>
  </div>
  <div id="hitFlash"></div>
  <div id="debug"></div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script>
    // Debug logging
    const debugDiv = document.getElementById('debug');
    function logDebug(message) {
      console.log(message);
      debugDiv.innerHTML += `<p>${message}</p>`;
      if (debugDiv.children.length > 5) {
        debugDiv.removeChild(debugDiv.firstChild);
      }
    }

    // Scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);
    logDebug('Three.js renderer initialized with WebXR');

    // WebXR session
    let xrSession = null;
    let xrReferenceSpace = null;
    let xrHitTestSource = null;
    let sceneRoot = new THREE.Group();
    scene.add(sceneRoot);
    logDebug('Scene root added');

    const startARButton = document.getElementById('startAR');
    const reticle = document.getElementById('reticle');
    startARButton.addEventListener('click', async () => {
      if (!navigator.xr) {
        logDebug('WebXR not supported');
        return;
      }
      try {
        xrSession = await navigator.xr.requestSession('immersive-ar', {
          requiredFeatures: ['hit-test', 'local-floor']
        });
        renderer.xr.setSession(xrSession);
        xrReferenceSpace = await xrSession.requestReferenceSpace('local-floor');
        xrHitTestSource = await xrSession.requestHitTestSource({ space: xrReferenceSpace });
        startARButton.style.display = 'none';
        reticle.style.display = 'block';
        logDebug('WebXR session started');
      } catch (error) {
        logDebug(`WebXR session failed: ${error.message}`);
      }
    });

    // Resize handling
    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      logDebug('Window resized');
    }
    window.addEventListener('resize', onResize);

    // Ground
    const textureLoader = new THREE.TextureLoader();
    const groundTexture = textureLoader.load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg', () => {
      logDebug('Ground texture loaded');
    }, undefined, (error) => {
      logDebug(`Ground texture error: ${error.message}`);
    });
    groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
    groundTexture.repeat.set(10, 15);
    const groundGeometry = new THREE.PlaneGeometry(10, 10, 88, 88);
    const groundMaterial = new THREE.MeshLambertMaterial({ map: groundTexture });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.visible = true;
    sceneRoot.add(ground);
    logDebug('Ground added to sceneRoot');

    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040, 1);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 20, 7.5);
    scene.add(directionalLight);
    logDebug('Lighting added');

    // Targets
    const targets = [];
    const targetGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.08, 64);
    function createBullseyeTexture() {
      const size = 256;
      const canvas = document.createElement('canvas');
      canvas.width = canvas.height = size;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(size / 2, size / 2, size / 2, 0, 2 * Math.PI); ctx.fill();
      ctx.fillStyle = '#ff2222';
      ctx.beginPath();
      ctx.arc(size / 2, size / 2, size / 2 * 0.8, 0, 2 * Math.PI); ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(size / 2, size / 2, size / 2 * 0.55, 0, 2 * Math.PI); ctx.fill();
      ctx.fillStyle = '#2222ff';
      ctx.beginPath();
      ctx.arc(size / 2, size / 2, size / 2 * 0.35, 0, 2 * Math.PI); ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(size / 2, size / 2, size / 2 * 0.18, 0, 2 * Math.PI); ctx.fill();
      ctx.fillStyle = '#ff2222';
      ctx.beginPath();
      ctx.arc(size / 2, size / 2, size / 2 * 0.09, 0, 2 * Math.PI); ctx.fill();
      return new THREE.CanvasTexture(canvas);
    }
    const bullseyeTexture = createBullseyeTexture();
    const targetMaterial = new THREE.MeshPhongMaterial({ map: bullseyeTexture, shininess: 30 });
    const distances = [7, 5, 6];

    function createDistanceLabelSprite(distance) {
      const canvas = document.createElement('canvas');
      canvas.width = 128;
      canvas.height = 32;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.font = 'bold 33px Arial';
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(`${distance}m`, canvas.width / 2, canvas.height / 2);
      const texture = new THREE.CanvasTexture(canvas);
      texture.needsUpdate = true;
      const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
      const sprite = new THREE.Sprite(material);
      sprite.scale.set(0.3, 0.1, 1);
      sprite._distanceCanvas = canvas;
      sprite._distanceCtx = ctx;
      sprite._distanceTexture = texture;
      sprite._distanceValue = distance;
      sprite.updateDistance = function (newDist) {
        this._distanceCtx.clearRect(0, 0, this._distanceCanvas.width, this._distanceCanvas.height);
        this._distanceCtx.font = 'bold 33px Arial';
        this._distanceCtx.fillStyle = 'rgba(0,0,0,0.7)';
        this._distanceCtx.fillRect(0, 0, this._distanceCanvas.width, this._distanceCanvas.height);
        this._distanceCtx.fillStyle = '#fff';
        this._distanceCtx.textAlign = 'center';
        this._distanceCtx.textBaseline = 'middle';
        this._distanceCtx.fillText(`${Math.round(newDist)}m`, this._distanceCanvas.width / 2, this._distanceCanvas.height / 2);
        this._distanceTexture.needsUpdate = true;
        this._distanceValue = newDist;
      };
      sprite.updateDistance(distance);
      return sprite;
    }

    function spawnTarget() {
      const dist = distances[Math.floor(Math.random() * distances.length)];
      const target = new THREE.Mesh(targetGeometry, targetMaterial.clone());
      target.position.set(Math.random() * 1.2 - 0.5, 0.1, -dist);
      target.rotation.x = Math.PI / 2;
      target.userData.distance = dist;
      target.visible = true;
      const labelSprite = createDistanceLabelSprite(dist);
      labelSprite.position.set(0, -0.3, -0.2);
      target.add(labelSprite);
      sceneRoot.add(target);
      targets.push({ mesh: target, distance: dist, hit: false, scale: 1, label: labelSprite });
      logDebug(`Target spawned at ${dist}m`);
    }
    distances.forEach(() => spawnTarget());

    // Crossbow
    const crossbowGroup = new THREE.Group();
    const bodyGeometry = new THREE.BoxGeometry(0.02, 0.05, 0.25);
    const woodTexture = textureLoader.load('https://threejs.org/examples/textures/hardwood2_diffuse.jpg', () => {
      logDebug('Wood texture loaded');
    }, undefined, (error) => {
      logDebug(`Wood texture error: ${error.message}`);
    });
    const bodyMaterial = new THREE.MeshPhongMaterial({ map: woodTexture, shininess: 50 });
    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
    body.position.set(0, 0, 0.02);
    crossbowGroup.add(body);

    const stickGeometry = new THREE.CylinderGeometry(0.0008, 0.0008, 0.045, 32);
    const stickMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000, shininess: 100 });
    const stick = new THREE.Mesh(stickGeometry, stickMaterial);
    stick.position.set(-0.006, 0.032, 0.13);
    crossbowGroup.add(stick);

    const leftLimbCurve = new THREE.CatmullRomCurve3([
      new THREE.Vector3(0.01, 0.02, -0.09),
      new THREE.Vector3(0.035, 0.02, -0.1),
      new THREE.Vector3(0.09, 0.02, -0.13),
      new THREE.Vector3(0.25, 0.005, -0.11)
    ]);
    const rightLimbCurve = new THREE.CatmullRomCurve3([
      new THREE.Vector3(-0.01, 0.02, -0.09),
      new THREE.Vector3(-0.035, 0.02, -0.1),
      new THREE.Vector3(-0.09, 0.02, -0.13),
      new THREE.Vector3(-0.25, 0.005, -0.11)
    ]);
    function createTaperedLimb(curve) {
      return new THREE.Mesh(
        new THREE.TubeGeometry(curve, 32, 0.013, 16, false),
        new THREE.MeshPhongMaterial({ color: 0xB8860B, shininess: 80 })
      );
    }
    const leftLimb = createTaperedLimb(leftLimbCurve);
    const rightLimb = createTaperedLimb(rightLimbCurve);
    crossbowGroup.add(leftLimb);
    crossbowGroup.add(rightLimb);

    const stringCurveSag = new THREE.CatmullRomCurve3([
      new THREE.Vector3(-0.25, 0.005, -0.11),
      new THREE.Vector3(0, 0.03, 0.12),
      new THREE.Vector3(0.25, 0.005, -0.11)
    ]);
    const stringCurveStraight = new THREE.CatmullRomCurve3([
      new THREE.Vector3(-0.25, 0.008, -0.1),
      new THREE.Vector3(0, 0.008, -0.1),
      new THREE.Vector3(0.25, 0.008, -0.1)
    ]);
    let bowStringGeometry = new THREE.TubeGeometry(stringCurveSag, 2, 0.001, 8, false);
    const stringMaterial = new THREE.MeshPhongMaterial({ color: 0x888888, shininess: 50 });
    const bowString = new THREE.Mesh(bowStringGeometry, stringMaterial);
    crossbowGroup.add(bowString);

    const triggerGeometry = new THREE.TorusGeometry(0.02, 0.005, 5, 100, Math.PI);
    const metalMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00, shininess: 100 });
    const triggerGuard = new THREE.Mesh(triggerGeometry, metalMaterial);
    triggerGuard.position.set(0, -0.015, 0.05);
    triggerGuard.rotation.x = Math.PI / 2;
    crossbowGroup.add(triggerGuard);

    const gripGeometry = new THREE.CylinderGeometry(0.01, 0.01, 0.04, 32);
    const grip = new THREE.Mesh(gripGeometry, bodyMaterial);
    grip.position.set(0, -0.02, 0.03);
    grip.rotation.x = Math.PI / 2;
    crossbowGroup.add(grip);

    crossbowGroup.visible = true;
    sceneRoot.add(crossbowGroup);
    crossbowGroup.position.set(0, 0.1, 0);
    logDebug('Crossbow group added to sceneRoot');

    // Arrow
    const arrowTipGeometry = new THREE.ConeGeometry(0.018, 0.05, 32);
    const arrowTipMaterial = new THREE.MeshPhongMaterial({ color: 0x888888, shininess: 100 });

    let arrow = null;
    let arrowVelocity = new THREE.Vector3();
    let isShooting = false;
    let lobAngle = 0;

    const loadedArrow = new THREE.Group();
    const loadedShaft = new THREE.Mesh(
      new THREE.CylinderGeometry(0.003, 0.003, 0.2, 32),
      new THREE.MeshPhongMaterial({ color: 0xFFD700, shininess: 50 })
    );
    const loadedTip = new THREE.Mesh(
      new THREE.ConeGeometry(0.005, -0.012, 22),
      arrowTipMaterial
    );
    loadedTip.position.set(0, -0.09, -0.002);
    loadedArrow.add(loadedShaft);
    loadedArrow.add(loadedTip);
    loadedArrow.position.set(0, 0.03, 0.015);
    loadedArrow.rotation.x = Math.PI / 2;
    loadedArrow.visible = true;
    crossbowGroup.add(loadedArrow);
    logDebug('Loaded arrow added to crossbow');

    // UI and Game State
    let score = 0;
    const scoreDisplay = document.getElementById('score');
    let playerHealth = 100;
    const healthBar = document.getElementById('healthBar');
    const healthLabel = document.getElementById('healthLabel');
    const hitFlash = document.getElementById('hitFlash');
    function showHitFlash() {
      if (!hitFlash) return;
      hitFlash.style.display = 'block';
      hitFlash.style.animation = 'hitFlashAnim 0.35s linear';
      setTimeout(() => {
        hitFlash.style.display = 'none';
        hitFlash.style.animation = 'none';
      }, 350);
    }
    function updateHealth() {
      const percent = Math.max(0, playerHealth) / 100;
      healthBar.style.width = (percent * 100) + '%';
      if (percent > 0.6) {
        healthBar.style.background = '#4caf50';
      } else if (percent > 0.3) {
        healthBar.style.background = '#ffb300';
      } else {
        healthBar.style.background = '#e53935';
      }
      healthLabel.textContent = Math.max(0, playerHealth);
    }
    let arrowsShot = 0;
    let arrowsHit = 0;
    const accuracyDisplay = document.getElementById('accuracy');
    function updateAccuracy() {
      let percent = arrowsShot === 0 ? 0 : Math.round((arrowsHit / arrowsShot) * 100);
      accuracyDisplay.textContent = percent + '%';
    }
    let targetSpeed = 0.005;
    let targetsShouldMove = false;
    let reloadTime = 1.2;
    let lastShotTime = -Infinity;
    let reloadingMsg = null;
    let gameOver = false;
    let scenePlaced = false;

    // Controls
    document.addEventListener('mousemove', (event) => {
      const mouseX = (event.clientX / window.innerWidth) * 2 - 1;
      const mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
      crossbowGroup.rotation.y = -mouseX * Math.PI / 4;
      crossbowGroup.rotation.x = mouseY * Math.PI / 8;
      stick.rotation.x = -crossbowGroup.rotation.x;
      lobAngle = (1 - (mouseY + 1) / 2) * 5;
      lobAngle = Math.max(0, Math.min(5, lobAngle));
    });

    let lastTouchX = null;
    let lastTouchY = null;
    let touchYaw = 0;
    let touchPitch = 0;
    document.addEventListener('touchstart', function (e) {
      if (e.touches.length === 1) {
        lastTouchX = e.touches[0].clientX;
        lastTouchY = e.touches[0].clientY;
        touchYaw = crossbowGroup.rotation.y;
        touchPitch = crossbowGroup.rotation.x;
      }
    }, { passive: false });
    document.addEventListener('touchmove', function (e) {
      if (e.touches.length === 1) {
        e.preventDefault();
        const dx = e.touches[0].clientX - lastTouchX;
        const dy = e.touches[0].clientY - lastTouchY;
        const yawFactor = Math.PI / 400;
        const pitchFactor = Math.PI / 600;
        crossbowGroup.rotation.y = touchYaw - dx * yawFactor;
        crossbowGroup.rotation.x = Math.max(-Math.PI / 4, Math.min(Math.PI / 4, crossbowGroup.rotation.x + dy * pitchFactor));
        stick.rotation.x = -crossbowGroup.rotation.x;
        const touchYNorm = (e.touches[0].clientY / window.innerHeight) * 2 - 1;
        lobAngle = (1 - (touchYNorm + 1) / 2) * 5;
        lobAngle = Math.max(0, Math.min(5, lobAngle));
      }
    }, { passive: false });

    function isTouchDevice() {
      return 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    }
    const shootBtn = document.getElementById('shootBtn');
    if (isTouchDevice()) {
      shootBtn.style.display = 'block';
    }

    if (isTouchDevice() && window.DeviceOrientationEvent) {
      let initialGamma = null, initialBeta = null;
      let baseYaw = 0, basePitch = 0;
      let orientationActive = false;
      function clampPitch(pitch) {
        return Math.max(-Math.PI / 4, Math.min(Math.PI / 4, pitch));
      }
      window.addEventListener('deviceorientation', function (event) {
        if (!orientationActive) {
          initialGamma = event.gamma;
          initialBeta = event.beta;
          baseYaw = crossbowGroup.rotation.y;
          basePitch = crossbowGroup.rotation.x;
          orientationActive = true;
        }
        if (orientationActive && initialGamma !== null && initialBeta !== null) {
          const yawFactor = Math.PI / 180 / 1.2;
          const pitchFactor = Math.PI / 180 / 1.5;
          let dGamma = event.gamma - initialGamma;
          let dBeta = event.beta - initialBeta;
          dGamma = Math.max(-60, Math.min(60, dGamma));
          dBeta = Math.max(-60, Math.min(60, dBeta));
          crossbowGroup.rotation.y = baseYaw - dGamma * yawFactor;
          crossbowGroup.rotation.x = clampPitch(basePitch + dBeta * pitchFactor);
          stick.rotation.x = -crossbowGroup.rotation.x;
          const normPitch = (crossbowGroup.rotation.x + Math.PI / 4) / (Math.PI / 2);
          lobAngle = (1 - normPitch) * 5;
          lobAngle = Math.max(0, Math.min(5, lobAngle));
        }
      }, true);
      document.addEventListener('touchstart', function () {
        initialGamma = null;
        initialBeta = null;
        orientationActive = false;
        baseYaw = crossbowGroup.rotation.y;
        basePitch = crossbowGroup.rotation.x;
      }, { passive: false });
    }

    function shootArrow() {
      const now = performance.now() / 1000;
      if (!isShooting && now - lastShotTime >= reloadTime && !gameOver) {
        isShooting = true;
        lastShotTime = now;
        loadedArrow.visible = false;
        bowString.geometry.dispose();
        bowString.geometry = new THREE.TubeGeometry(stringCurveStraight, 2, 0.001, 8, false);
        arrowsShot++;
        updateAccuracy();
        arrow = new THREE.Group();
        const shaft = new THREE.Mesh(
          new THREE.CylinderGeometry(0.005, 0.005, 0.08, 12),
          new THREE.MeshPhongMaterial({ color: 0xFFD700, shininess: 50 })
        );
        const tip = new THREE.Mesh(
          new THREE.ConeGeometry(0.01, 0.08, 12),
          arrowTipMaterial
        );
        tip.position.set(0, 0.08, 0);
        arrow.add(shaft);
        arrow.add(tip);
        loadedArrow.updateMatrixWorld();
        const loadedWorldPos = new THREE.Vector3();
        loadedArrow.getWorldPosition(loadedWorldPos);
        arrow.position.copy(loadedWorldPos);
        arrow.quaternion.copy(crossbowGroup.quaternion);
        sceneRoot.add(arrow);
        const direction = new THREE.Vector3(0, 0, -1);
        direction.applyQuaternion(crossbowGroup.quaternion);
        const lobRad = lobAngle * Math.PI / 180;
        const lobMatrix = new THREE.Matrix4().makeRotationX(lobRad);
        direction.applyMatrix4(lobMatrix).normalize();
        const baseSpeed = 5.5;
        arrowVelocity.set(
          direction.x * baseSpeed,
          direction.y * baseSpeed,
          direction.z * baseSpeed
        );
        arrow.lookAt(arrow.position.clone().add(arrowVelocity));
        logDebug('Arrow shot');
      }
    }
    document.addEventListener('click', shootArrow);
    shootBtn.addEventListener('touchstart', function (e) {
      e.preventDefault();
      shootArrow();
    });
    shootBtn.addEventListener('click', function (e) {
      e.preventDefault();
      shootArrow();
    });

    let aimMode = false;
    function aim() {
      aimMode = true;
      document.getElementById('aimBtn').style.display = 'none';
      document.getElementById('backBtn').style.display = 'block';
      stick.geometry.dispose();
      stick.geometry = new THREE.CylinderGeometry(0.0001, 0.0001, 0.0384, 99);
      logDebug('Aim mode enabled');
    }
    function exitAim() {
      aimMode = false;
      document.getElementById('aimBtn').style.display = 'block';
      document.getElementById('backBtn').style.display = 'none';
      stick.geometry.dispose();
      stick.geometry = new THREE.CylinderGeometry(0.0008, 0.0008, 0.045, 32);
      logDebug('Aim mode disabled');
    }
    document.getElementById('aimBtn').addEventListener('click', aim);
    document.getElementById('backBtn').addEventListener('click', exitAim);

    const enemyArrows = [];
    function spawnEnemyArrow(targetMesh, scoreForFalseRatio) {
      const arrowGroup = new THREE.Group();
      const shaft = new THREE.Mesh(
        new THREE.CylinderGeometry(0.005, 0.005, 0.08, 12),
        new THREE.MeshPhongMaterial({ color: 0x888888, shininess: 30 })
      );
      const tip = new THREE.Mesh(
        new THREE.ConeGeometry(0.01, 0.03, 12),
        new THREE.MeshPhongMaterial({ color: 0xff0000, shininess: 80 })
      );
      tip.position.set(0, 0.055, 0);
      arrowGroup.add(shaft);
      arrowGroup.add(tip);
      arrowGroup.position.copy(targetMesh.position);
      const playerPos = camera.position.clone();
      let falseRatio = scoreForFalseRatio < 150 ? 0.3 : 0.2;
      let miss = Math.random() < falseRatio;
      let targetVec = playerPos.clone();
      if (miss) {
        targetVec.x += (Math.random() - 0.5) * 0.6;
        targetVec.y += (Math.random() - 0.5) * 0.6;
      }
      const dir = targetVec.sub(targetMesh.position).normalize();
      const lobStrength = 0.42;
      const lobDir = dir.clone();
      lobDir.y += lobStrength;
      lobDir.normalize();
      arrowGroup.userData.velocity = lobDir.multiplyScalar(0.25);
      arrowGroup.userData.gravity = true;
      arrowGroup.userData.is70mArrow = (targetMesh.userData && targetMesh.userData.distance === 7);
      enemyArrows.push(arrowGroup);
      sceneRoot.add(arrowGroup);
      logDebug('Enemy arrow spawned');
    }
    const enemyShotInterval = 4.5;

    let time = 0;
    function animate(timestamp, frame) {
      if (gameOver) return;
      requestAnimationFrame(animate);
      time += 0.05;

      // WebXR hit-test
      if (frame && xrSession && xrHitTestSource && !scenePlaced) {
        const hitTestResults = frame.getHitTestResults(xrHitTestSource);
        if (hitTestResults.length > 0) {
          const hit = hitTestResults[0];
          const pose = hit.getPose(xrReferenceSpace);
          if (pose) {
            const matrix = new THREE.Matrix4().fromArray(pose.transform.matrix);
            sceneRoot.matrix.copy(matrix);
            sceneRoot.matrix.decompose(sceneRoot.position, sceneRoot.quaternion, sceneRoot.scale);
            sceneRoot.visible = true;
            if (xrSession) {
              xrSession.addEventListener('select', () => {
                scenePlaced = true;
                reticle.style.display = 'none';
                logDebug('Scene placed on surface');
              });
            }
            logDebug('Hit-test surface detected');
          }
        }
      }

      targets.forEach(target => {
        if (!target.hit) {
          target.scale = 1 + 0.01 * Math.sin(time);
          target.mesh.scale.set(1, target.scale, 1);
        }
        if (target.label) {
          target.label.quaternion.copy(camera.quaternion);
          const distToPlayer = Math.abs(target.mesh.position.z);
          target.label.updateDistance(distToPlayer);
        }
        if (target.distance !== 7) {
          if (score > 50) {
            targetsShouldMove = true;
          }
          if (score > 120) {
            targetSpeed = 0.007;
          }
          if (targetsShouldMove) {
            target.mesh.position.z += targetSpeed;
          }
          if (target.mesh.position.z >= -0.5 && !target.hit && !gameOver) {
            gameOver = true;
            const infoDiv = document.getElementById('info');
            const gameOverMsg = document.createElement('div');
            gameOverMsg.style.fontSize = '2em';
            gameOverMsg.style.color = 'yellow';
            gameOverMsg.style.marginTop = '10px';
            gameOverMsg.textContent = 'GAME OVER';
            infoDiv.appendChild(gameOverMsg);
            logDebug('Game over: Target reached player');
          }
        } else {
          if (!target.hit && !gameOver) {
            if (!target.lastEnemyShotTime) target.lastEnemyShotTime = 0;
            const now = performance.now() / 1000;
            if (now - target.lastEnemyShotTime > enemyShotInterval) {
              spawnEnemyArrow(target.mesh, score);
              target.lastEnemyShotTime = now;
            }
          }
        }
      });

      crossbowGroup.position.y = 0.1 + 0.005 * Math.sin(time * 0.5);

      if (aimMode) {
        const stickTipLocal = new THREE.Vector3(0, 0.019, 0.02);
        stick.updateMatrixWorld();
        const stickTipWorld = stick.localToWorld(stickTipLocal.clone());
        camera.position.copy(stickTipWorld);
        const forward = new THREE.Vector3(0, 0.01, -0.08).applyQuaternion(crossbowGroup.getWorldQuaternion(new THREE.Quaternion())).normalize();
        camera.lookAt(stickTipWorld.clone().add(forward));
      } else {
        const stickTipLocal = new THREE.Vector3(0, 0.05, 0.1);
        stick.updateMatrixWorld();
        const stickTipWorld = stick.localToWorld(stickTipLocal.clone());
        const stickDir = new THREE.Vector3(0, 1, 0).applyQuaternion(stick.getWorldQuaternion(new THREE.Quaternion())).normalize();
        const up = new THREE.Vector3(0, 1, 0);
        const cameraOffset = stickDir.clone().multiplyScalar(-0.035).add(up.clone().multiplyScalar(0.008));
        camera.position.copy(stickTipWorld.clone().add(cameraOffset));
        const forward = new THREE.Vector3(0, -0.02, -0.1).applyQuaternion(crossbowGroup.getWorldQuaternion(new THREE.Quaternion())).normalize();
        camera.lookAt(stickTipWorld.clone().add(forward));
      }

      if (!isShooting && (!reloadingMsg || (performance.now() / 1000 - lastShotTime >= reloadTime))) {
        loadedArrow.visible = true;
        if (bowString.geometry.parameters.path !== stringCurveSag) {
          bowString.geometry.dispose();
          bowString.geometry = new THREE.TubeGeometry(stringCurveSag, 2, 0.001, 8, false);
        }
      }

      if (isShooting && arrow) {
        arrow.position.x += arrowVelocity.x * 0.05;
        arrow.position.y += arrowVelocity.y * 0.05;
        arrow.position.z += arrowVelocity.z * 0.05;
        arrowVelocity.y -= 0.981 * 0.05;
        const velocityDirection = arrowVelocity.clone().normalize();
        if (velocityDirection.lengthSq() > 0) {
          arrow.lookAt(arrow.position.clone().add(velocityDirection));
          arrow.rotateX(Math.PI / 2);
        }
        targets.forEach(target => {
          if (!target.hit && arrow) {
            const distance = arrow.position.distanceTo(target.mesh.position);
            if (distance < 0.12) {
              target.hit = true;
              target.mesh.material.color.set(0x00FF00);
              score += 10;
              scoreDisplay.textContent = score;
              arrowsHit++;
              updateAccuracy();
              sceneRoot.remove(arrow);
              arrow = null;
              isShooting = false;
              sceneRoot.remove(target.mesh);
              const idx = targets.indexOf(target);
              if (idx !== -1) targets.splice(idx, 1);
              spawnTarget();
              logDebug('Target hit, score: ' + score);
            }
          }
        });
        if (isShooting && arrow && (arrow.position.z < -7 || arrow.position.y < 0)) {
          sceneRoot.remove(arrow);
          arrow = null;
          isShooting = false;
          logDebug('Arrow missed');
        }
      }

      for (let i = enemyArrows.length - 1; i >= 0; i--) {
        const eArrow = enemyArrows[i];
        if (eArrow.userData.gravity) {
          eArrow.userData.velocity.y -= 0.006;
        }
        eArrow.position.add(eArrow.userData.velocity);
        const velDir = eArrow.userData.velocity.clone().normalize();
        if (velDir.lengthSq() > 0) {
          eArrow.lookAt(eArrow.position.clone().add(velDir));
          eArrow.rotateX(Math.PI / 2);
        }
        if (eArrow.position.distanceTo(camera.position) <= 0.09 && !gameOver) {
          if (eArrow.userData.is70mArrow) {
            playerHealth -= 4;
            updateHealth();
            showHitFlash();
            logDebug('Player hit, health: ' + playerHealth);
          }
          sceneRoot.remove(eArrow);
          enemyArrows.splice(i, 1);
          if (playerHealth <= 0) {
            playerHealth = 0;
            updateHealth();
            gameOver = true;
            const infoDiv = document.getElementById('info');
            const gameOverMsg = document.createElement('div');
            gameOverMsg.style.fontSize = '2em';
            gameOverMsg.style.color = 'red';
            gameOverMsg.style.marginTop = '10px';
            gameOverMsg.textContent = 'GAME OVER';
            infoDiv.appendChild(gameOverMsg);
            logDebug('Game over: Player health depleted');
          }
          continue;
        }
        if (eArrow.position.distanceTo(camera.position) > 12 || eArrow.position.y < -0.5) {
          sceneRoot.remove(eArrow);
          enemyArrows.splice(i, 1);
          logDebug('Enemy arrow removed');
        }
      }

      if (reloadingMsg) {
        const now = performance.now() / 1000;
        if (now - lastShotTime >= reloadTime) {
          reloadingMsg.remove();
          reloadingMsg = null;
          logDebug('Reload complete');
        }
      }

      renderer.render(scene, camera);
    }
    animate();

    const restartBtn = document.getElementById('restartBtn');
    restartBtn.addEventListener('click', function () {
      targets.forEach(t => sceneRoot.remove(t.mesh));
      targets.length = 0;
      if (arrow) {
        sceneRoot.remove(arrow);
        arrow = null;
      }
      enemyArrows.forEach(ea => sceneRoot.remove(ea));
      enemyArrows.length = 0;
      score = 0;
      scoreDisplay.textContent = score;
      arrowsShot = 0;
      arrowsHit = 0;
      updateAccuracy();
      playerHealth = 100;
      updateHealth();
      document.getElementById('healthBarContainer').style.display = 'block';
      const infoDiv = document.getElementById('info');
      const gameOverMsg = infoDiv.querySelector('div');
      if (gameOverMsg) gameOverMsg.remove();
      targetSpeed = 0.005;
      targetsShouldMove = false;
      gameOver = false;
      crossbowGroup.position.set(0, 0.1, 0);
      crossbowGroup.rotation.set(0, 0, 0);
      camera.position.set(0, 0.15, 0.25);
      camera.lookAt(0, 0.1, 0);
      aimMode = false;
      document.getElementById('aimBtn').style.display = 'block';
      document.getElementById('backBtn').style.display = 'none';
      stick.geometry.dispose();
      stick.geometry = new THREE.CylinderGeometry(0.0008, 0.0008, 0.045, 32);
      loadedArrow.visible = true;
      distances.forEach(() => spawnTarget());
      scenePlaced = false;
      reticle.style.display = 'block';
      animate();
      logDebug('Game restarted');
    });

    if (isTouchDevice() && window.top === window.self) {
      document.body.style.overflow = "hidden";
      document.getElementById('iframeContainer').style.display = 'block';
      document.getElementById('gameIframe').src = window.location.href;
      Array.from(document.body.children).forEach(function (el) {
        if (el.id !== 'iframeContainer') el.style.display = 'none';
      });
      logDebug('Iframe mode activated for touch device');
    }
  </script>
</body>
</html>
